<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Script Obfuscator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        textarea {
            width: 100%;
            height: 300px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 10px;
            resize: vertical;
            box-sizing: border-box;
        }
        
        .buttons {
            margin: 15px 0;
            text-align: center;
        }
        
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
        }
        
        button:hover {
            background: #005a8b;
        }
        
        h3 {
            margin: 20px 0 10px 0;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h3>Put script here</h3>
        <textarea id="inputScript" placeholder="local script = 'your code here'"></textarea>
        
        <div class="buttons">
            <button onclick="obfuscateScript()">Obfuscate</button>
            <button onclick="clearScript()">Clear</button>
            <button onclick="copyScript()">Copy</button>
        </div>
        
        <h3>Output</h3>
        <textarea id="outputScript" readonly></textarea>
    </div>

    <script>
        // Direct implementation of your Hercules modules

        // Watermark module
        function addWatermark(code) {
            return "--[Obfuscated by Hercules v1.6.2 | hercules-obfuscator.xyz/discord | hercules-obfuscator.xyz/source]\n" + code;
        }

        // Variable Renamer module
        function variableRenamer(code) {
            const varencNames = {};
            const luaFunctions = [
                "assert", "collectgarbage", "dofile", "loadfile", "loadstring",
                "ipairs", "pairs", "tonumber", "tostring", "type", "print",
                "_G", "_VERSION", "write", "sort",
                "math.abs", "math.acos", "math.asin", "math.atan", "math.atan2",
                "math.ceil", "math.cos", "math.cosh", "math.deg", "math.exp",
                "math.floor", "math.fmod", "math.frexp", "math.ldexp", "math.log",
                "math.log10", "math.max", "math.min", "math.modf", "math.pi",
                "math.pow", "math.rad", "math.random", "math.randomseed", "math.sin",
                "math.sinh", "math.sqrt", "math.tan", "math.tanh",
                "string.byte", "string.char", "string.dump", "string.find",
                "string.format", "string.gmatch", "string.gsub", "string.len",
                "string.lower", "string.match", "string.rep", "string.reverse",
                "string.sub", "string.upper",
                "table.concat", "table.insert", "table.remove", "table.sort",
                "table.pack", "table.unpack", "game:GetService"
            ];

            const reservedWords = {
                "if": true, "then": true, "else": true, "elseif": true, "end": true,
                "for": true, "while": true, "do": true, "repeat": true, "until": true,
                "function": true, "local": true, "return": true, "break": true, "continue": true,
                "and": true, "or": true, "not": true, "in": true, "nil": true,
                "true": true, "false": true
            };

            function generateRandomName() {
                const len = Math.floor(Math.random() * (12 - 8 + 1)) + 8;
                const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                let name = "";
                for (let i = 0; i < len; i++) {
                    name += charset[Math.floor(Math.random() * charset.length)];
                }
                return name;
            }

            function replaceUnquoted(input, target, replacement) {
                const placeholder = "!!!";
                let protectedInput = input.replace(/(['"])(?:(?=(\\?))\2.)*?\1/g, function(match, quote) {
                    return match.replace(new RegExp(target.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), placeholder);
                });
                
                let result = protectedInput.replace(new RegExp(`\\b${target.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'g'), replacement);
                result = result.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), target);
                return result;
            }

            function obfuscateLocalVariables(code) {
                const localVarPattern = /local\s+([a-zA-Z_][a-zA-Z0-9_,\s]*)\s*=/g;
                const varMap = {};
                let obfuscatedCode = code;
                
                let match;
                while ((match = localVarPattern.exec(code)) !== null) {
                    const localVars = match[1];
                    const vars = localVars.split(',');
                    for (let i = 0; i < vars.length; i++) {
                        const varName = vars[i].trim();
                        if (varName.length > 1 && !varencNames[varName] && !reservedWords[varName]) {
                            varMap[varName] = generateRandomName();
                        }
                    }
                }
                
                for (const [originalVar, obfuscatedVar] of Object.entries(varMap)) {
                    obfuscatedCode = replaceUnquoted(obfuscatedCode, originalVar, obfuscatedVar);
                }
                
                return obfuscatedCode;
            }

            function obfuscateFunctions(code) {
                const funcMap = {};
                const argMap = {};
                let obfuscatedCode = code;
                
                const funcPattern = /function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\(([a-zA-Z0-9_,\s]*)\)/g;
                let match;
                while ((match = funcPattern.exec(code)) !== null) {
                    const funcName = match[1];
                    const args = match[2];
                    
                    if (!reservedWords[funcName] && !funcMap[funcName]) {
                        funcMap[funcName] = generateRandomName();
                    }
                    
                    if (args) {
                        const argList = args.split(',');
                        for (let arg of argList) {
                            arg = arg.trim();
                            if (arg && !reservedWords[arg] && !argMap[arg]) {
                                argMap[arg] = generateRandomName();
                            }
                        }
                    }
                }
                
                obfuscatedCode = obfuscatedCode.replace(/function\s+([a-zA-Z_][a-zA-Z0-9_]*)/g, function(match, funcName) {
                    return "function " + (funcMap[funcName] || funcName);
                });
                
                for (const [originalFunc, obfuscatedFunc] of Object.entries(funcMap)) {
                    const regex = new RegExp(`\\b${originalFunc.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\(`, 'g');
                    obfuscatedCode = obfuscatedCode.replace(regex, obfuscatedFunc + "(");
                }
                
                for (const [originalArg, obfuscatedArg] of Object.entries(argMap)) {
                    obfuscatedCode = replaceUnquoted(obfuscatedCode, originalArg, obfuscatedArg);
                }
                
                return obfuscatedCode;
            }

            const renamedVars = [];
            const assignmentLines = [];
            let obfuscatedCode = obfuscateLocalVariables(code);
            obfuscatedCode = obfuscateFunctions(obfuscatedCode);
            
            for (const functionName of luaFunctions) {
                if (code.indexOf(functionName) !== -1) {
                    if (!varencNames[functionName]) {
                        const newName = generateRandomName();
                        varencNames[functionName] = newName;
                        renamedVars.push(newName);
                        assignmentLines.push(newName + " = " + functionName + ";");
                    }
                    const regex = new RegExp(functionName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + "\\(", 'g');
                    obfuscatedCode = obfuscatedCode.replace(regex, varencNames[functionName] + "(");
                }
            }
            
            const localDeclaration = renamedVars.length > 0 ? "local " + renamedVars.join(", ") : "";
            const assignments = assignmentLines.length > 0 ? "\n" + assignmentLines.join(" ") : "";
            
            return localDeclaration + assignments + "\n" + obfuscatedCode;
        }

        // String Encoder module
        function stringEncoder(code) {
            const randomDecryptName = generateRandomName();
            const randomIsValidCharName = generateRandomName();
            const randomResultName = generateRandomName();
            const randomCodeName = generateRandomName();
            const randomOffsetName = generateRandomName();
            const randomByteName = generateRandomName();
            const randomNewByteName = generateRandomName();

            function generateRandomName(len) {
                len = len || Math.floor(Math.random() * (12 - 8 + 1)) + 8;
                const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
                let name = "";
                for (let i = 0; i < len; i++) {
                    name += charset[Math.floor(Math.random() * charset.length)];
                }
                return name;
            }

            function isValidChar(byte) {
                return (byte >= 48 && byte <= 57) || (byte >= 65 && byte <= 90) || (byte >= 97 && byte <= 122);
            }

            function caesarCipher(data, offset) {
                let result = [];
                let i = 0;
                while (i < data.length) {
                    const byte = data.charCodeAt(i);
                    if (byte === 92 && i < data.length - 1) {
                        const nextChar = data.substr(i + 1, 1);
                        if (nextChar === "2" && data.substr(i + 2, 1) === "7") {
                            result.push(String.fromCharCode(byte));
                            result.push(nextChar);
                            result.push(data.substr(i + 2, 1));
                            i += 2;
                        } else {
                            result.push(String.fromCharCode(byte));
                            result.push(nextChar);
                            i += 1;
                        }
                    } else if (isValidChar(byte)) {
                        let newByte;
                        if (byte >= 48 && byte <= 57) {
                            newByte = ((byte - 48 + offset) % 10) + 48;
                        } else if (byte >= 65 && byte <= 90) {
                            newByte = ((byte - 65 + offset) % 26) + 65;
                        } else if (byte >= 97 && byte <= 122) {
                            newByte = ((byte - 97 + offset) % 26) + 97;
                        }
                        result.push(String.fromCharCode(newByte));
                    } else {
                        result.push(String.fromCharCode(byte));
                    }
                    i++;
                }
                return result.join("");
            }

            const decodeFunction = `
local function ${randomIsValidCharName}(${randomByteName})
    return (${randomByteName} >= 48 and ${randomByteName} <= 57) or (${randomByteName} >= 65 and ${randomByteName} <= 90) or (${randomByteName} >= 97 and ${randomByteName} <= 122)
end
	
local function ${randomDecryptName}(${randomCodeName}, ${randomOffsetName})
    local ${randomResultName} = {}
    for i = 1, #${randomCodeName} do
        local ${randomByteName} = ${randomCodeName}:byte(i)
        if ${randomIsValidCharName}(${randomByteName}) then
            local ${randomNewByteName}
            if ${randomByteName} >= 48 and ${randomByteName} <= 57 then
                ${randomNewByteName} = ((${randomByteName} - 48 - ${randomOffsetName} + 10) % 10) + 48
            elseif ${randomByteName} >= 65 and ${randomByteName} <= 90 then
                ${randomNewByteName} = ((${randomByteName} - 65 - ${randomOffsetName} + 26) % 26) + 65
            elseif ${randomByteName} >= 97 and ${randomByteName} <= 122 then
                ${randomNewByteName} = ((${randomByteName} - 97 - ${randomOffsetName} + 26) % 26) + 97
            end
            table.insert(${randomResultName}, string.char(${randomNewByteName}))
        else
            table.insert(${randomResultName}, string.char(${randomByteName}))
        end
    end
    return table.concat(${randomResultName})
end

local function ${randomIsValidCharName}(${randomByteName})
    return (${randomByteName} >= 48 and ${randomByteName} <= 57) or (${randomByteName} >= 65 and ${randomByteName} <= 90) or (${randomByteName} >= 97 and ${randomByteName} <= 122)
end
`;

            code = code.replace(/\\"/g, '!@!').replace(/\\'/g, "@!@");

            code = code.replace(/(['"])(.*)?\1/g, function(match, quote, str) {
                if (typeof str === "string") {
                    str = str.replace(/!@!/g, '\\"').replace(/@!@/g, "\\'");

                    let offset = Math.floor(Math.random() * 9) + 1;
                    if (str.match(/[a-zA-Z]/)) {
                        offset = Math.floor(Math.random() * 25) + 1;
                    }
                    const encodedStr = caesarCipher(str, offset);
                    return `${randomDecryptName}(${quote}${encodedStr}${quote}, ${offset})`;
                } else {
                    return str;
                }
            });

            return decodeFunction + "\n" + code;
        }

        // Opaque Predicate Injector module
        function opaquePredicateInjector(code) {
            function generatePredicates() {
                const predicates = [
                    function() {
                        const n = Math.floor(Math.random() * 90) + 10;
                        return `if (${n} % 1 == 0 and ${n} >= ${n}) then`;
                    },
                    function() {
                        const x = Math.floor(Math.random() * 10) + 1;
                        return `if (${x} % ${x} == 0) then`;
                    },
                    function() {
                        const angle = Math.floor(Math.random() * 360);
                        return `if (math.sin(${angle})^2 + math.cos(${angle})^2 >= 0.99999) then`;
                    },
                    function() {
                        const str = Math.floor(Math.random() * 8999) + 1000;
                        return `if (select(2, pcall(function() return tonumber('${str.toString(16)}', 16) end)) ~= nil) then`;
                    },
                    function() {
                        const size = Math.floor(Math.random() * 3) + 2;
                        const arr = Array(size).fill("1").join(",");
                        return `if (#{${arr}} == ${size}) then`;
                    },
                    function() {
                        const a = Math.floor(Math.random() * 10) + 1;
                        const b = Math.floor(Math.random() * 10) + 11;
                        return `if ((${a} < ${b}) == not (${a} >= ${b})) then`;
                    }
                ];
                return predicates[Math.floor(Math.random() * predicates.length)]();
            }

            function isInjectSafe(statement) {
                if (statement.match(/^\s*[{}]\s*$/) ||
                    statement.match(/^\s*$/) ||
                    !statement.match(/.+;/)) {
                    return false;
                }
                const unsafes = [
                    /^\s*for\s+/,
                    /^\s*while\s+/,
                    /^\s*if\s+/,
                    /^\s*repeat\s+/,
                    /^\s*until\s+/,
                    /^\s*function\s+/,
                    /^\s*local\s+function/,
                    /^\s*do\s+/
                ];
                for (const pattern of unsafes) {
                    if (statement.match(pattern)) {
                        return false;
                    }
                }
                if (statement.match(/^\s*if\s+.+\s+then\s+.+\s+end\s*;?$/)) {
                    return false;
                }
                return true;
            }

            function injectPredicates(block) {
                if (block.match(/\s*end\s*;?$/) || block.match(/^\s*return/)) {
                    return block;
                } else {
                    const predicate = generatePredicates();
                    return predicate + block + " end;";
                }
            }

            if (typeof code !== "string") {
                throw new Error("Input must be a string");
            }
            
            try {
                let result = code.replace(/([ \t]*)([^\n;]*;)/g, function(match, ws, statement) {
                    if (isInjectSafe(statement)) {
                        return ws + injectPredicates(statement);
                    } else {
                        return ws + statement;
                    }
                });
                result = result.replace(/([ \t]*)(return\s+[^\n;]+;)/g, function(match, ws, returnStmt) {
                    return ws + returnStmt;
                });
                return result;
            } catch (error) {
                throw new Error("Failed to process code: " + error.toString());
            }
        }

        // Garbage Code Inserter module
        function garbageCodeInserter(code, garbageBlocks = 20) {
            function generateRandomVariableName() {
                const name = [];
                for (let i = 0; i < 6; i++) {
                    name.push(String.fromCharCode(Math.floor(Math.random() * 26) + 97));
                }
                return name.join("");
            }

            function generateRandomNumber(max = 100) {
                return Math.floor(Math.random() * max) + 1;
            }

            const codeTypes = {
                variable: function() {
                    return `local ${generateRandomVariableName()} = ${generateRandomNumber()}`;
                },
                while_loop: function() {
                    return `while ${Math.random() > 0.5 ? 'true' : 'false'} do local _ = ${generateRandomNumber(100)} break end`;
                },
                for_loop: function() {
                    return `for ${generateRandomVariableName()} = 1, ${generateRandomNumber(10)} do local _ = ${generateRandomNumber()} end`;
                },
                if_statement: function() {
                    return `if ${Math.random() > 0.5 ? 'true' : 'false'} then local _ = ${generateRandomNumber()} end`;
                },
                function_def: function() {
                    return `local function ${generateRandomVariableName()}(${generateRandomVariableName()}) local _ = ${generateRandomNumber()} end`;
                }
            };

            const codeTypeKeys = Object.keys(codeTypes);

            function generateRandomCode() {
                return codeTypes[codeTypeKeys[Math.floor(Math.random() * codeTypeKeys.length)]]();
            }

            function generateGarbage(blocks, sep = "\n") {
                const garbageCode = [];
                for (let i = 0; i < blocks; i++) {
                    const code = generateRandomCode();
                    if (!code.match(/while true/) && !code.match(/for \w+ = \d+, \d+ do local _ = \d+ end/)) {
                        garbageCode.push(code);
                    }
                }
                return garbageCode.join(sep);
            }

            if (typeof code !== "string" || code.length === 0) {
                throw new Error("Input code must be a non-empty string");
            }
            if (typeof garbageBlocks !== "number") {
                throw new Error("garbage_blocks must be a number");
            }
            
            const prefixGarbage = generateGarbage(garbageBlocks);
            const suffixGarbage = generateGarbage(garbageBlocks);
            return [prefixGarbage, code, suffixGarbage].join("\n");
        }

        // Control Flow Obfuscator module  
        function controlFlowObfuscator(code) {
            function controlFlow(code, n, a, depth = 0, depthValues = []) {
                n = n || Math.floor(Math.random() * 7000);
                a = n;
                depthValues.push({n, a});

                const operators = [">", "<", "=="];
                const whileOperator = operators[Math.floor(Math.random() * 3)];
                
                const step = Math.floor(Math.random() * 990) + 10;
                const maxIterations = 3;
                if (whileOperator === "<") {
                    a = n + (step * maxIterations);
                } else if (whileOperator === ">") {
                    a = n - (step * maxIterations);
                    if (a < 0) a = 0;
                } else if (whileOperator === "==") {
                    a = n;
                }

                const threshold = n + step;

                let src = depth === 0 ? `local thing = ${n};\nlocal thing2 = ${a};\nlocal counter = 0;\nlocal threshold = ${threshold};\n` : "";

                src += `while thing ${whileOperator} thing2 and counter < ${maxIterations} do\n`;
                src += `    thing = thing + ${step};\n`;
                src += "    counter = counter + 1;\n";
                src += "    if thing < threshold then\n";

                function generateSpoof() {
                    const spoofLines = [
                        `local temp = ${Math.floor(Math.random() * 100)}; temp = temp * 2;`,
                        "local str = 'dummy'; str = str .. str;",
                        `local x = ${Math.floor(Math.random() * 50)}; x = x - ${Math.floor(Math.random() * 10)};`,
                        "local tbl = {1, 2, 3}; table.sort(tbl, function(a, b) return a > b end);"
                    ];
                    return spoofLines[Math.floor(Math.random() * spoofLines.length)];
                }

                if (Array.isArray(code) && depth === code.length - 1) {
                    src += `        ${generateSpoof()}\n`;
                    src += `    else\n        ${code[0]}\n        break\n`;
                } else {
                    src += `        ${generateSpoof()}\n`;
                    src += `    else\n        ${code}\n        break\n`;
                }

                src += "    end\nend\n";

                if (Math.random() > 0.5) {
                    src += `local dummy = 1; dummy = dummy + ${Math.floor(Math.random() * 10)};\n`;
                }

                return depth === 0 ? src : {src, n, a};
            }

            if (typeof code !== "string") {
                throw new Error("Input code must be a string");
            }

            return controlFlow(code);
        }

        // Compressor module
        function compressor(code) {
            if (typeof code !== "string") {
                throw new Error("Input code must be a string.");
            }
            if (code.length < 10 || code.match(/^[\s\d\p]*$/)) {
                return code.match(/^\s*(.*?)\s*$/) ? code.match(/^\s*(.*?)\s*$/)[1] || "" : "";
            }

            const strings = {};
            let stringCount = 0;
            const keywordsMap = {};

            const LUA_KEYWORDS = [
                "and", "break", "do", "else", "elseif", "end", "false", "for", "function",
                "goto", "if", "in", "local", "nil", "not", "or", "repeat", "return",
                "then", "true", "until", "while"
            ];

            const KW_PLACEHOLDER_PRE = "@@KW_";
            const KW_PLACEHOLDER_POST = "_KW@@";
            const STR_PLACEHOLDER_PRE = "@@S_";
            const STR_PLACEHOLDER_POST = "_S@@";

            function preserveStrings(c) {
                c = c.replace(/\[(=*)\[(.*?)\]\1\]/g, function(match, equals, str) {
                    stringCount++;
                    const key = STR_PLACEHOLDER_PRE + stringCount + STR_PLACEHOLDER_POST;
                    strings[key] = "[" + equals + "[" + str + "]" + equals + "]";
                    return key;
                });
                c = c.replace(/"(.*?)"/g, function(match, str) {
                    if (str.indexOf("\\") === -1 && str.indexOf(STR_PLACEHOLDER_PRE) !== -1) {
                        return '"' + str + '"';
                    }
                    stringCount++;
                    const key = STR_PLACEHOLDER_PRE + stringCount + STR_PLACEHOLDER_POST;
                    strings[key] = '"' + str + '"';
                    return key;
                });
                c = c.replace(/'(.*?)'/g, function(match, str) {
                    if (str.indexOf("\\") === -1 && str.indexOf(STR_PLACEHOLDER_PRE) !== -1) {
                        return "'" + str + "'";
                    }
                    stringCount++;
                    const key = STR_PLACEHOLDER_PRE + stringCount + STR_PLACEHOLDER_POST;
                    strings[key] = match;
                    return key;
                });
                return c;
            }

            function preserveKeywords(c) {
                for (const keyword of LUA_KEYWORDS) {
                    const placeholder = KW_PLACEHOLDER_PRE + keyword + KW_PLACEHOLDER_POST;
                    keywordsMap[placeholder] = keyword;
                    c = c.replace(new RegExp(`([^\\w_])(${keyword})([^\\w_])`, 'g'), `$1${placeholder}$3`);
                    c = c.replace(new RegExp(`^(${keyword})([^\\w_])`, 'g'), `${placeholder}$2`);
                    c = c.replace(new RegExp(`([^\\w_])(${keyword})$`, 'g'), `$1${placeholder}`);
                    c = c.replace(new RegExp(`^(${keyword})$`, 'g'), placeholder);
                }
                return c;
            }

            function restoreKeywords(c) {
                for (const [placeholder, keyword] of Object.entries(keywordsMap)) {
                    c = c.replace(new RegExp(placeholder.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), keyword);
                }
                return c;
            }

            function restoreStrings(c) {
                for (let i = stringCount; i >= 1; i--) {
                    const key = STR_PLACEHOLDER_PRE + i + STR_PLACEHOLDER_POST;
                    c = c.replace(new RegExp(key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), strings[key]);
                }
                return c;
            }

            code = preserveStrings(code);
            code = preserveKeywords(code);

            code = code.replace(/--\[\[.*?\]\]/g, "");
            code = code.replace(/--[^\n]*/g, "");

            code = code.replace(/[\n\r]+/g, " ");
            code = code.replace(/\s+/g, " ");

            code = code.replace(/\s*\.\.\s*/g, "..");
            code = code.replace(/\s*([+\-*/%.\\^#<>=~,;:(){}[\]])\s*/g, "$1");
            code = code.replace(/\s*\.\s*/g, ".");
            code = code.replace(/\.\./, "..");

            code = code.match(/^\s*(.*?)\s*$/) ? code.match(/^\s*(.*?)\s*$/)[1] || "" : "";

            code = restoreKeywords(code);
            code = restoreStrings(code);

            return code;
        }

        // Anti-tamper module
        function antiTamper(code) {
            const d = generateRandomName();
            const t = generateRandomName();
            const e = generateRandomName();
            const antiTamperCode = `do
    local ${d},${t},${e} = debug,type,error
    if ${t}(${d}) ~= "table" then ${e}("Script protection active") end
end
`;
            return antiTamperCode + "\n" + code;
        }

        // Wrap In Function module
        function wrapInFunction(code) {
            return `return (function(...) ${code} end)(...)`;
        }

        function generateRandomName(len) {
            len = len || Math.floor(Math.random() * (12 - 8 + 1)) + 8;
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
            let name = "";
            for (let i = 0; i < len; i++) {
                name += charset[Math.floor(Math.random() * charset.length)];
            }
            return name;
        }

        // Single obfuscation pass
        function obfuscateOnce(code) {
            let obfuscated = code;
            
            // Apply pipeline in order from your config
            obfuscated = stringEncoder(obfuscated);
            obfuscated = garbageCodeInserter(obfuscated, Math.floor(Math.random() * 15) + 10);
            obfuscated = opaquePredicateInjector(obfuscated);
            obfuscated = controlFlowObfuscator(obfuscated);
            obfuscated = variableRenamer(obfuscated);
            obfuscated = garbageCodeInserter(obfuscated, Math.floor(Math.random() * 10) + 5);
            obfuscated = antiTamper(obfuscated);
            obfuscated = compressor(obfuscated);
            obfuscated = wrapInFunction(obfuscated);
            
            return obfuscated;
        }

        // Main obfuscation pipeline - obfuscates 5 times automatically
        function obfuscateScript() {
            const input = document.getElementById('inputScript').value;
            if (!input.trim()) {
                alert('Please enter a script to obfuscate');
                return;
            }

            let obfuscated = input;

            try {
                // Obfuscate 5 times automatically
                for (let i = 0; i < 5; i++) {
                    obfuscated = obfuscateOnce(obfuscated);
                }
                
                // Add watermark at the end
                obfuscated = addWatermark(obfuscated);

                document.getElementById('outputScript').value = obfuscated;
            } catch (error) {
                alert('Error during obfuscation: ' + error.message);
            }
        }

        function clearScript() {
            document.getElementById('inputScript').value = '';
            document.getElementById('outputScript').value = '';
        }

        function copyScript() {
            const output = document.getElementById('outputScript');
            if (!output.value) {
                alert('Nothing to copy');
                return;
            }
            
            output.select();
            output.setSelectionRange(0, 99999);
            document.execCommand('copy');
            
            const originalBg = output.style.background;
            output.style.background = '#d4edda';
            setTimeout(() => {
                output.style.background = originalBg;
            }, 200);
        }
    </script>
</body>
</html>
